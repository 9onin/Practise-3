Давайте разберём программу по шагам, чтобы понять, что будет выведено на консоль.

 1. Иерархия классов
- `Person` — базовый класс с свойством `Name` (по умолчанию `"Ben"`) и конструктором, который принимает `name` и устанавливает `Name = "Tim"`.
- `Employee` — наследник `Person`, добавляет свойство `Company`. Его конструктор принимает `name` и `company`, вызывает конструктор базового класса с аргументом `"Bob"`, а затем инициализирует `Company = company`.

 2. Создание объекта `Employee`
Строка:
```csharp
Employee emp = new Employee("Tom", "Microsoft") { Name = "Sam" };
```
выполняет следующие действия:

#### a) Вызов конструктора `Employee(string name, string company)`
- `name = "Tom"`, `company = "Microsoft"`.
- Конструктор вызывает `base("Bob")`, то есть конструктор `Person("Bob")`.

#### b) Вызов конструктора `Person(string name)`
- `name = "Bob"`.
- Сначала инициализируется свойство `Name = "Ben"` (значение по умолчанию).
- Затем выполняется `Name = "Tim"` (в конструкторе `Person`).
- **Теперь `Name = "Tim"`.**

 c) Возврат в конструктор `Employee`
- `Company = company` → `Company = "Microsoft"`.

 d) Инициализация свойства в инициализаторе объекта `{ Name = "Sam" }`
- После выполнения конструктора `Employee` выполняется присваивание `Name = "Sam"`.
- **Теперь `Name = "Sam"`.**

 3. Вывод `emp.Name`
На момент вывода `Console.WriteLine(emp.Name)` значение `Name` равно `"Sam"`, потому что инициализатор объекта выполняется после конструктора.

### Итоговый вывод:
```
Sam
```

 Почему не другие варианры (`Ben`, `Tim`, `Bob`, `Tom`)?
- `"Ben"` — значение по умолчанию, но оно перезаписывается в конструкторе `Person`.
- `"Tim"` — устанавливается в конструкторе `Person`, но потом перезаписывается инициализатором.
- `"Bob"` — передаётся в `base("Bob")`, но не влияет на итоговое значение `Name`.
- `"Tom"` — аргумент конструктора `Employee`, но не используется для `Name`.

 Правильный ответ:
```
Sam
```
Sam
```
